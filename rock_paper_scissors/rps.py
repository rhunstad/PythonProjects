from tkinter import *from random import randintfrom time import sleepwidth = 800height = widthstep = 5tile_size = 20horizon = 25num_of_each = 5num_tiles = 3*num_of_eachtiles = []distances = [[j for j in range(i)] for i in range(num_tiles)]x_total = 0y_total = 0root = Tk()root.title("Rock Paper Scissors")root.geometry('%sx%s' % (width, height))canvas = Canvas(root, width=width, height=height, highlightthickness=0)canvas.pack()# RPS Valuesvals = {    0: ["#ff0000", 'rock', num_of_each],    1: ["#00ff00", 'paper', num_of_each],    2: ["#0000ff", 'scissors', num_of_each]}def setup():    for i in range(num_tiles):        x = randint(horizon, width - horizon)        y = randint(horizon, height - horizon)        tile = Tile(x, y, i % 3)        tiles.append(tile)    canvas.bind_all("<Key>", game)    root.mainloop()    passdef game(event):    while not is_over():        iterate()        battle()        generate()        canvas.update()        sleep(0.25)    print("OVer")    print(vals[0][2], vals[1][2], vals[2][2])def iterate():    global tiles    global distances    for i in range(num_tiles):        d = [((tiles[i].x - tiles[j].x)**2 + (tiles[i].y - tiles[j].y)**2)**(1/2) for j in range(num_tiles)]        d = [1000 if i == 0 else i for i in d]        closest = d.index(min(d))                x_step = step if tiles[closest].x > tiles[i].x else -1*step        y_step = step if tiles[closest].y > tiles[i].y else -1*step                tiles[i].x = min(max(tiles[i].x + x_step, horizon), width-horizon)        tiles[i].y = min(max(tiles[i].y + y_step, horizon), height-horizon)                for j in range(i):            distances[i][j] = ((tiles[i].x - tiles[j].x)**2 + (tiles[i].y - tiles[j].y)**2)**(1/2)def battle():    global queue    global tiles    for i in range(num_tiles):        for j in range(i):            if distances[i][j] < horizon:                win = winner(tiles[i].val, tiles[j].val)                if win is not None:                    if win == tiles[i].val:                        tiles[j].val = win                        vals[tiles[i].val][2] = vals[tiles[i].val][2] - 1                     else:                        tiles[i].val = win                        vals[tiles[j].val][2] = vals[tiles[j].val][2] - 1                        def generate():    for i in range(num_tiles):        tiles[i].regenerate()        def winner(p1, p2):    if (p1 + 1) % 3 == p2:        return p2    elif p1 == p2:        return None    else:        return p1def is_over():    if sum((vals[0][2], vals[1][2], vals[2][2])) == max(vals[0][2], vals[1][2], vals[2][2]):        if max(vals[0][2], vals[1][2], vals[2][2]) > 0:            return True    return Falseclass Tile(object):    r, p, s = 0, 0, 0    end_game = False        def __init__(self, x, y, val):        global tiles        self.x = x        self.y = y        self.val = val        self.square = canvas.create_rectangle(self.x, self.y, self.x + tile_size, self.y + tile_size, fill=vals[self.val][0], outline=vals[self.val][0])    def regenerate(self):        canvas.delete(self.square)        self.square = canvas.create_rectangle(self.x, self.y, self.x + tile_size, self.y + tile_size, fill=vals[self.val][0], outline=vals[self.val][0])                setup()