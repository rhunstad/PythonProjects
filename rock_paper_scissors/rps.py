# from tkinter import *import tkinter as tkfrom random import randintimport timeimport playsoundimport threadingfrom datetime import datetimewidth = 800height = 800tile_size = 40step = round(tile_size*.1, 0)horizon = tile_size # round(tile_size*1.1,0)num_of_each = 5num_tiles = 3*num_of_eachtiles = []distances = [[j for j in range(i)] for i in range(num_tiles)]images = []r_time = 0p_time = 0s_time = 0root = tk.Tk()root.title("Rock Paper Scissors")root.geometry('%sx%s' % (width, height))canvas = tk.Canvas(root, width=width, height=height, highlightthickness=0)canvas.pack()# RPS Valuesvals = {    0: ["#9c9c9c", 'rock', num_of_each, tk.PhotoImage(file='rock.png'), "playsound.playsound('rock_sfx.mp3')"],    1: ["#ebebeb", 'paper', num_of_each, tk.PhotoImage(file='paper.png'), "playsound.playsound('paper_sfx.mp3')"],    2: ["#000000", 'scissors', num_of_each, tk.PhotoImage(file='scissors.png'), "playsound.playsound('scissors_sfx.mp3')"]}def setup(event):    global num_tiles    global tiles    global distances    global images    global vals        if not is_over():        for i in range(num_tiles):            x = randint(horizon, width - horizon)            y = randint(horizon, height - horizon)            tile = Tile(x, y, i % 3)            tiles.append(tile)        canvas.bind_all("<Key>", game)        root.mainloop()    else:        canvas.delete("all")        num_tiles = 3*num_of_each        tiles = []        distances = [[j for j in range(i)] for i in range(num_tiles)]        images = []        vals = {            0: ["#9c9c9c", 'rock', num_of_each, tk.PhotoImage(file='rock.png')],            1: ["#ebebeb", 'paper', num_of_each, tk.PhotoImage(file='paper.png')],            2: ["#000000", 'scissors', num_of_each, tk.PhotoImage(file='scissors.png')]        }        for i in range(num_tiles):            x = randint(horizon, width - horizon)            y = randint(horizon, height - horizon)            tile = Tile(x, y, i % 3)            tiles.append(tile)        canvas.bind_all("<Key>", game)        root.mainloop()def game(event):    while not is_over():        iterate()        battle()        generate()        canvas.update()        time.sleep(.1)    canvas.bind_all("<Key>", setup)def iterate():    global tiles    global distances    for i in range(num_tiles):        d = [((tiles[i].x - tiles[j].x)**2 + (tiles[i].y - tiles[j].y)**2)**(1/2) for j in range(num_tiles)]        d = [2000 if d[k] == 0 or tiles[k].val == tiles[i].val else d[k] for k in range(len(d))]        closest = d.index(min(d))                x_step = step if tiles[closest].x > tiles[i].x else -1*step        y_step = step if tiles[closest].y > tiles[i].y else -1*step                tiles[i].x = min(max(tiles[i].x + x_step, horizon), width-horizon)        tiles[i].y = min(max(tiles[i].y + y_step, horizon), height-horizon)                for j in range(i):            distances[i][j] = ((tiles[i].x - tiles[j].x)**2 + (tiles[i].y - tiles[j].y)**2)**(1/2)def battle():    global queue    global tiles    for i in range(num_tiles):        for j in range(i):            if distances[i][j] < horizon:                win = winner(tiles[i].val, tiles[j].val)                if win is not None:                    if win == tiles[i].val:                        vals[tiles[i].val][2] = vals[tiles[i].val][2] + 1                        vals[tiles[j].val][2] = vals[tiles[j].val][2] - 1                        tiles[j].val = win                        x = threading.Thread(target=sound, args=(tiles[i].val,))                        x.start()                    else:                        vals[tiles[i].val][2] = vals[tiles[i].val][2] - 1                        vals[tiles[j].val][2] = vals[tiles[j].val][2] + 1                        tiles[i].val = win                        x = threading.Thread(target=sound, args=(tiles[j].val,))                        x.start()                        def generate():    for i in range(num_tiles):        tiles[i].regenerate()             def sound(val):    if val == 0:        global r_time        if time.time() - r_time > 0:            playsound.playsound('rock_sfx.mp3')            r_time = time.time()    elif val == 1:        global p_time        if time.time() - p_time > 0:            playsound.playsound('paper_sfx.mp3')            p_time = time.time()    elif val == 2:        global s_time        if time.time() - s_time > 0:            playsound.playsound('scissors_sfx.mp3')            s_time = time.time()def winner(p1, p2):    if (p1 + 1) % 3 == p2:        return p2    elif p1 == p2:        return None    else:        return p1def is_over():    if sum((vals[0][2], vals[1][2], vals[2][2])) == max(vals[0][2], vals[1][2], vals[2][2]):        if max(vals[0][2], vals[1][2], vals[2][2]) > 0:            return True    return Falseclass Tile(object):        def __init__(self, x, y, val):        global tiles        global images        self.x = x        self.y = y        self.val = val        # self.square = canvas.create_oval(self.x, self.y, self.x + tile_size, self.y + tile_size, fill=vals[self.val][0], outline="#000000")        # self.square = canvas.create_rectangle(self.x, self.y, self.x + tile_size, self.y + tile_size, fill=vals[self.val][0], outline="#000000")        img = tk.PhotoImage(file=f"{vals[self.val][1]}.png")        images.append(img)        self.square = canvas.create_image((self.x, self.y), image=img, anchor='nw')    def regenerate(self):        canvas.delete(self.square)        # self.square = canvas.create_oval(self.x, self.y, self.x + tile_size, self.y + tile_size, fill=vals[self.val][0], outline="#000000")        # self.square = canvas.create_rectangle(self.x, self.y, self.x + tile_size, self.y + tile_size, fill=vals[self.val][0], outline="#000000")        img = tk.PhotoImage(file=f"{vals[self.val][1]}.png")        images.append(img)        self.square = canvas.create_image((self.x, self.y), image=img, anchor='nw')        setup(0)